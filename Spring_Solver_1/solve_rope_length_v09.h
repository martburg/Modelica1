/**
 * @file solve_rope_length.h
 * @brief Public API for the 3D spring-mass rope solver.
 *
 * This module provides a numerically robust solver for a rope modeled as a chain
 * of mass points and springs, under the influence of gravity. It includes:
 *
 * - Initialization using a cubic parabola matching arc length
 * - Dynamic relaxation with velocity damping and adaptive timestep
 * - Newton-Raphson refinement with analytical Jacobian and line search
 * - Force decomposition (weight-based and Newton-based) at endpoints
 *
 * This header defines the external interface for linking against the solver
 * as a shared library (DLL or .so), usable from C, C++, Python (via ctypes),
 * Modelica, or other environments.
 */
#ifndef SOLVE_ROPE_LENGTH_H
#define SOLVE_ROPE_LENGTH_H

#ifdef _WIN32
#define DLL_EXPORT __declspec(dllexport)
#else
#define DLL_EXPORT
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    SOLVE_SUCCESS = 0,
    SOLVE_ERROR_NAN = -1,
    SOLVE_ERROR_LINE_SEARCH_FAILED = -2,
    SOLVE_ERROR_JACOBIAN_FAILED = -3,
    SOLVE_ERROR_MAX_ITER = -4,
    SOLVE_ERROR_ALLOC = -5,
    SOLVE_ERROR = -6,
    INVALD_INPUT = -7
} SolveStatus;

/**
 * @brief Solve a spring-mass rope under gravity.
 *
 * This is the top-level function for external use (e.g., via Python ctypes or Modelica).
 * It initializes, relaxes, refines the system, and computes endpoint forces.
 *
 * @param[in] P1               3D coordinates of fixed endpoint 1
 * @param[in] P2               3D coordinates of fixed endpoint 2
 * @param[in] n                Number of mass nodes (excluding fixed endpoints)
 * @param[in] total_mass       Total mass of the rope (kg)
 * @param[in] length_factor    Ratio of unstretched rope length to straight distance
 * @param[in] rope_diameter    Diameter of rope (m)
 * @param[in] youngs_modulus   Young's modulus of rope material (Pa)
 * @param[in] g_vec            3D gravity vector (m/sÂ²)
 *
 * @param[out] out_positions   (n-1)*3 array of 3D coordinates of mass nodes
 * @param[out] F_P1_out_w      Force on P1 via weight-based decomposition (3D vector)
 * @param[out] F_P2_out_w      Force on P2 via weight-based decomposition (3D vector)
 * @param[out] F_P1_out_n      Force on P1 via Newton-based decomposition (3D vector)
 * @param[out] F_P2_out_n      Force on P2 via Newton-based decomposition (3D vector)
 * @param[out] Length_initial  Total rope length after cubic-parabola init
 * @param[out] Length_dynamic  Total rope length after dynamic relaxation
 * @param[out] Length_newton   Total rope length after Newton refinement
 * @param[out] Status_dynamic  Solver status after dynamic relaxation
 * @param[out] Status_newton   Solver status after Newton refinement
 *
 * @return SolveStatus
 *     - SOLVE_SUCCESS (0)
 *     - SOLVE_ERROR_NAN (-1)
 *     - SOLVE_ERROR_LINE_SEARCH_FAILED (-2)
 *     - SOLVE_ERROR_JACOBIAN_FAILED (-3)
 *     - SOLVE_ERROR_MAX_ITER (-4)
 *     - SOLVE_ERROR_ALLOC (-5)
 *     - SOLVE_ERROR (-6)
 *     - INVALD_INPUT (-7)
 */
DLL_EXPORT int solve_rope_length(
    double* P1, double* P2,
    int n, double total_mass, double length_factor,
    double rope_diameter, double youngs_modulus,
    double* g_vec, double* out_positions,
    double* F_P1_out_w,
    double* F_P2_out_w,
    double* F_P1_out_n,
    double* F_P2_out_n,
    double* Length_initial,
    double* Length_cat,
    double* Length_dynamic,
    double* Length_newton,
    int* Status_dynamic,
    int* Status_newton,
    int debug_level);

/**
 * @defgroup InternalSolverFunctions Internal Solver Functions
 * @brief Lower-level internal routines used by the rope solver.
 *
 * These functions implement the specific numerical techniques used during
 * initialization, dynamic relaxation, and Newton-based refinement. They are not
 * intended to be called directly by external code but may be useful for testing,
 * debugging, or integration into larger solvers.
 * @{
 */
/**
 * @ingroup InternalSolverFunctions
 * @brief Initialize rope node positions using a cubic parabola.
 *
 * Positions are generated by tracing a sagging cubic curve between endpoints,
 * matching the target arc length via Newton-Raphson search. Used to initialize
 * nodes before dynamic relaxation.
 *
 * @param[out] x               Output array of internal node positions (scaled)
 * @param[in] P1               3D start point (scaled)
 * @param[in] P2               3D end point (scaled)
 * @param[in] n                Number of mass nodes
 * @param[in] g_vec            Normalized gravity vector (scaled)
 * @param[out] s0_post_init    Per-segment lengths of initialized shape
 * @param[in] L0               Total rope length (unscaled)
 * @param[in] scale_pos        Position scaling factor
 * @return Total arc length of the initialized rope (scaled)
 */

double init_dynamic_relaxation(
    double* x, const double* P1, const double* P2,
    int n, const double* g_vec,
    double* s0_post_init, double L0, double scale_pos);

/**
 * @ingroup InternalSolverFunctions
 * @brief Perform dynamic relaxation on a spring-mass rope.
 *
 * Applies critical damping and iterative velocity integration to allow the system
 * to reach equilibrium under gravity. Uses adaptive timestep and damping.
 *
 * @param[in] x                Initial node positions (scaled)
 * @param[out] x_out           Relaxed node positions (scaled)
 * @param[in] P1, P2           Fixed endpoint positions (scaled)
 * @param[in] n                Number of nodes
 * @param[in] s0_post_init     Segment rest lengths
 * @param[in] c                Spring stiffness (scaled)
 * @param[in] m                Mass per node (scaled)
 * @param[in] g_vec            Gravity vector (scaled)
 * @param[in] dt_given         Optional timestep override (0 = auto)
 * @param[in] max_steps        Maximum number of iterations
 * @param[in] scale_pos        Position scaling (used internally)
 * @return 0 on success, or SOLVE_ERROR_MAX_ITER
 */
int dynamic_relaxation(
    double* x, double *x_out, const double* P1, const double* P2, int n,
    double* s0_post_init, double c, double m, const double* g_vec,
    double dt_given, int max_steps, double scale_pos);

/**
 * @ingroup InternalSolverFunctions
 * @brief Refine relaxed rope using a 3D Newton-Raphson solver.
 *
 * Solves for static equilibrium with analytical Jacobian and Armijo line search.
 * Starts from a relaxed input and iteratively applies Newton updates.
 *
 * @param[in] x                Relaxed starting positions
 * @param[out] x_out           Output refined positions
 * @param[in] P1, P2           Fixed endpoints
 * @param[in] n                Number of nodes
 * @param[in] s0               Segment rest lengths
 * @param[in] k                Spring stiffness
 * @param[in] m                Node mass
 * @param[in] g_vec            Gravity vector
 * @param[in] step_size        Initial step scale
 * @param[in] max_iter         Max iterations
 * @param[in] tol              Convergence tolerance
 * @return 0 on success, error code otherwise
 */
int analytic_newton_solver_3d(
    double *x, double *x_out, const double *P1, const double *P2, int n,
    const double *s0, double k, double m, const double *g_vec, double step_size, int max_iter, double tol);

/**
 * @ingroup InternalSolverFunctions
 * @brief Estimate endpoint forces via rope weight partitioning.
 *
 * Splits rope weight based on the lowest node and tangent directions at endpoints.
 * Used to infer applied forces assuming weight is shared along tangent projection.
 *
 * @param[in] P1, P2           Fixed endpoints
 * @param[in] x                Internal node positions
 * @param[in] n                Number of mass nodes
 * @param[in] g_vec            Gravity vector
 * @param[in] total_mass       Total rope mass
 * @param[out] F_P1_out        Estimated force on P1
 * @param[out] F_P2_out        Estimated force on P2
 */
void report_endpoint_forces_weight_partitioned(
    const double* P1, const double* P2, const double* x, int n,
    const double* g_vec, double total_mass,
    double* F_P1_out, double* F_P2_out);

/**
 * @ingroup InternalSolverFunctions
 * @brief Compute deviation of total spring force from gravity.
 *
 * Compares net endpoint forces to total weight vector magnitude and
 * returns the absolute difference. Useful as a diagnostic measure.
 *
 * @param[in] total_mass       Total mass of rope
 * @param[in] g_vec            Gravity vector
 * @param[in] F_P1_out_n       Newton-based force at P1
 * @param[in] F_P2_out_n       Newton-based force at P2
 * @return Difference between net spring force magnitude and m*g
 */
double Delta_F(double total_mass, double *g_vec, double F_P1_out_n[3], double F_P2_out_n[3]);

/** @} */

#ifdef __cplusplus
}
#endif

#endif // SOLVE_ROPE_LENGTH_H
